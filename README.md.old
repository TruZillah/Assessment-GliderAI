# Python Practice Assessment (JPMC-style)

This practice set mirrors typical coding questions you may see in a JPMC/Glider proctored assessment:
- Prefilled function stubs with clear contracts
- Focus on correctness, clarity, and edge cases
- No external libraries required
- **24 problems** ranging from Easy to Hard difficulty

## ðŸš€ Quick Start

### Option 1: Web Interface (Recommended)

Start the Flask server:
```bash
wsl python3 app.py
```

Then open your browser to: **http://127.0.0.1:5000**

**New Features**:
- ðŸ“‹ **Copy pseudocode** to clipboard with one click
- ðŸŽ¯ **Difficulty badges** (Easy/Medium/Hard)
- â±ï¸ **Timer** to track time per problem
- ðŸ’¡ **Collapsible hints** with memory (remembers your preference)
- âŒ¨ï¸ **Keyboard shortcuts** (Ctrl+Enter to run tests)
- See [FEATURES.md](FEATURES.md) for complete feature list

### Option 2: Command Line

Run all tests:

```bash
wsl python3 run_tests.py
```

If you prefer native Windows Python:
```cmd
C:\Users\ubeyo\AppData\Local\Programs\Python\Python313\python.exe run_tests.py
```

## Problems

1. `summation(a, b) -> int` â€” return the sum of two integers.
2. `is_palindrome(s) -> bool` â€” check if a string is a palindrome ignoring non-alphanumerics and case.
3. `second_largest(nums) -> Optional[int]` â€” return the second largest distinct value or `None` if it doesnâ€™t exist.
4. `frequency_sort(s) -> str` â€” sort characters by frequency (desc), then lexicographically (asc).
5. `merge_intervals(intervals) -> List[List[int]]` â€” merge overlapping intervals.
6. `two_sum(nums, target) -> List[int]` â€” return indices of two numbers adding to target, or `[-1, -1]`.
7. `balanced_brackets(s) -> bool` â€” return whether brackets are balanced: (), {}, []

Each file contains:
- Function signature and docstring with examples
- `# TODO` marker where you should implement logic

## Tips for proctored settings
- Read the contract carefully (inputs, outputs, constraints).
- Cover edge cases (empty input, duplicates, negatives, large ranges).
- Prefer O(n) or O(n log n) solutions where possible.
- Use clear variable names and small helper functions when useful.

Good luck! Focus on correctness first, then efficiency.
