"""
Flask web app for practicing multi-language assessment problems in the browser.
Supports Python, JavaScript, Java, and C++.
"""

import io
import json
import os
import re
import shutil
import ssl
import subprocess
import sys
import tempfile
import traceback
from contextlib import redirect_stderr, redirect_stdout
from typing import Optional
from urllib import request as urlrequest
from urllib.error import HTTPError, URLError

from flask import Flask, jsonify, request, send_from_directory

app = Flask(__name__, static_folder='static', static_url_path='')

# Simple .env loader to avoid extra deps
def _load_env_file(path: str = '.env'):
    try:
        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' in line:
                    k, v = line.split('=', 1)
                    os.environ[k.strip()] = v.strip()
    except FileNotFoundError:
        pass

def _parse_env_file(path: str = '.env') -> dict:
    """Parse .env file and return dict without modifying os.environ."""
    env_dict = {}
    try:
        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' in line:
                    k, v = line.split('=', 1)
                    env_dict[k.strip()] = v.strip()
    except FileNotFoundError:
        pass
    return env_dict

def _validate_env_dict(env_dict: dict) -> bool:
    """Check if env dict has a valid OPENAI_API_KEY."""
    key = env_dict.get('OPENAI_API_KEY', '')
    return key.startswith('sk-') and len(key) > 20

def reload_env_if_valid() -> Optional[str]:
    """
    Re-read .env if it exists and is valid, then return the effective API key.
    Returns the key from the file if valid, else from os.environ, else None.
    """
    env_dict = _parse_env_file()
    if env_dict and _validate_env_dict(env_dict):
        # Valid .env found; update os.environ
        for k, v in env_dict.items():
            os.environ[k] = v
        return env_dict.get('OPENAI_API_KEY')
    # Fallback to existing env
    existing = os.environ.get('OPENAI_API_KEY', '')
    return existing if existing else None

# Load .env on startup
_load_env_file()

# Language executors
def execute_python(code: str, test_args: list, problem_name: str) -> tuple:
    """Execute Python code with test arguments."""
    namespace = {}
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    
    try:
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            exec(code, namespace)
            func = namespace.get(problem_name)
            if not func:
                raise NameError(f'Function {problem_name} not found')
            result = func(*test_args)
        return result, stdout_capture.getvalue(), stderr_capture.getvalue()
    except Exception as e:
        return None, stdout_capture.getvalue(), f'{type(e).__name__}: {e}'

def execute_javascript(code: str, test_args: list, problem_name: str) -> tuple:
    """Execute JavaScript code with Node.js."""
    temp_dir = tempfile.mkdtemp()
    try:
        js_file = os.path.join(temp_dir, 'solution.js')
        test_code = f"""{code}

// Test harness
const args = {json.dumps(test_args)};
const result = {problem_name}(...args);
console.log('RESULT:' + JSON.stringify(result));
"""
        with open(js_file, 'w') as f:
            f.write(test_code)
        
        proc = subprocess.run(
            ['node', js_file],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if proc.returncode != 0:
            raise RuntimeError(f'JavaScript error: {proc.stderr}')
        
        output = proc.stdout
        for line in output.split('\n'):
            if line.startswith('RESULT:'):
                result_str = line[7:]
                result = json.loads(result_str)
                return result, output, proc.stderr
        
        raise RuntimeError(f'Could not find RESULT in output: {output}')
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)

def execute_java(code: str, test_args: list, problem_name: str) -> tuple:
    """Execute Java code by compiling and running."""
    temp_dir = tempfile.mkdtemp()
    try:
        java_file = os.path.join(temp_dir, 'TestRunner.java')
        class_file = os.path.join(temp_dir, 'TestRunner.class')
        
        # Build test harness
        args_json = json.dumps(test_args)
        test_code = f"""
import java.util.*;
import com.google.gson.*;

{code.replace('public class', 'class')}

public class TestRunner {{
    public static void main(String[] args) {{
        Gson gson = new Gson();
        String argsJson = {json.dumps(args_json)};
        JsonArray argsArray = gson.fromJson(argsJson, JsonArray.class);
        
        Solution sol = new Solution();
        Object result = null;
        
        // Call method dynamically based on problem
        // (simplified - assumes first method in Solution class)
        result = sol.{problem_name}(/* parse args */);
        
        System.out.println("RESULT:" + gson.toJson(result));
    }}
}}
"""
                    # Optional per-problem hints shown in the UI
                    HINTS = {
                        # Small/representative problems get language-specific notes; others default to the same hint across languages
                        'summation': {
                            'python': {'bullets': ['Inputs are integers; just return a + b.', 'No overflow concerns in Python ints.'], 'pseudocode': 'def summation(a, b):\\n    return a + b\\n'},
                            'javascript': {'bullets': ['Be careful with implicit type coercion; ensure inputs are numbers.', 'Return a + b; Node.js will handle number addition.'], 'pseudocode': 'function summation(a, b) {\\n    return a + b;\\n}\\n'},
                            'java': {'bullets': ['Use primitive ints to avoid boxing overhead.', 'Return a + b from the method.'], 'pseudocode': 'public int summation(int a, int b) {\\n    return a + b;\\n}\\n'},
                            'cpp': {'bullets': ['Use int (or long) depending on expected range.', 'Return a + b from the function.'], 'pseudocode': 'int summation(int a, int b) {\\n    return a + b;\\n}\\n'},
                        },

                        'palindrome': {
                            'python': {'bullets': ['Filter to alphanumeric using str.isalnum and lowercase.', 'Use two pointers i/j; compare and move inward.', 'Empty string is a palindrome.'], 'pseudocode': 'def is_palindrome(s):\\n    t = [c.lower() for c in s if c.isalnum()]\\n    i, j = 0, len(t)-1\\n    while i < j:\\n        if t[i] != t[j]:\\n            return False\\n        i += 1; j -= 1\\n    return True\\n'},
                            'javascript': {'bullets': ['Normalize with regex: keep alphanumeric and toLowerCase().', 'Use two indices or reverse the string and compare.'], 'pseudocode': 'function is_palindrome(s) {\\n    const t = s.replace(/[^a-z0-9]/gi, "").toLowerCase();\\n    return t === t.split("").reverse().join("");\\n}\\n'},
                            'java': {'bullets': ['Use Character.isLetterOrDigit and Character.toLowerCase for normalization.', 'Use two-pointer approach on a char array.'], 'pseudocode': 'public boolean is_palindrome(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    for (char c: s.toCharArray()) if (Character.isLetterOrDigit(c)) sb.append(Character.toLowerCase(c));\\n    String t = sb.toString(); return new StringBuilder(t).reverse().toString().equals(t);\\n}\\n'},
                            'cpp': {'bullets': ['Use isalnum from <cctype> and tolower for normalization.', 'Build a filtered string and compare with reverse.'], 'pseudocode': 'bool is_palindrome(string s) {\\n    string t; for (char c: s) if (isalnum((unsigned char)c)) t.push_back(tolower((unsigned char)c)); return equal(t.begin(), t.begin()+t.size()/2, t.rbegin());\\n}\\n'},
                        },

                        # Problems where a single language-agnostic hint suffices — replicate across languages for now
                        'second_largest': {
                            'python': {'bullets': ['Track top1 and top2 distinct values in one pass.', 'Update top2 when you update top1; skip duplicates.'], 'pseudocode': 'def second_largest(nums):\\n    top1 = top2 = None\\n    for x in nums:\\n        if top1 is None or x > top1:\\n            if x != top1: top2 = top1\\n            top1 = x\\n        elif x != top1 and (top2 is None or x > top2):\\n            top2 = x\\n    return top2\\n'},
                            'javascript': {'bullets': ['Track top1 and top2 distinct values in one pass.', 'Update top2 when you update top1; skip duplicates.'], 'pseudocode': 'function second_largest(nums) {\\n    let top1 = null, top2 = null; for (const x of nums) { if (top1 === null || x > top1) { if (x !== top1) top2 = top1; top1 = x; } else if (x !== top1 && (top2 === null || x > top2)) { top2 = x; } } return top2; }\\n'},
                            'java': {'bullets': ['Track top1 and top2 distinct values in one pass.', 'Update top2 when you update top1; skip duplicates.'], 'pseudocode': 'public Integer second_largest(int[] nums) { Integer top1=null, top2=null; for (int x: nums) { if (top1==null||x>top1){ if (x!=top1) top2=top1; top1=x; } else if (x!=top1 && (top2==null||x>top2)){ top2=x; } } return top2; }\\n'},
                            'cpp': {'bullets': ['Track top1 and top2 distinct values in one pass.', 'Update top2 when you update top1; skip duplicates.'], 'pseudocode': 'int second_largest(vector<int>& nums) { int top1=INT_MIN, top2=INT_MIN; bool has1=false, has2=false; for (int x: nums){ if (!has1||x>top1){ if (has1 && x!=top1) { top2=top1; has2=true; } top1=x; has1=true; } else if ((!has2||x>top2) && x!=top1){ top2=x; has2=true; } } return has2?top2:INT_MIN; }\\n'},
                        },

                        'frequency_sort': {
                            'python': {'bullets': ['Count with collections.Counter.', 'Sort by (-freq, char).', 'Join char repeated freq times.'], 'pseudocode': 'from collections import Counter\\n\\ncounts = Counter(s)\\nparts = sorted(counts.items(), key=lambda kv: (-kv[1], kv[0]))\\nreturn "".join(ch*freq for ch,freq in parts)\\n'},
                            'javascript': {'bullets': ['Count with a Map/object.', 'Sort by (-freq, char).'], 'pseudocode': 'function frequency_sort(s){ const counts=new Map(); for(const c of s) counts.set(c,(counts.get(c)||0)+1); const parts = [...counts.entries()].sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0])); return parts.map(([ch,f])=>ch.repeat(f)).join(""); }\\n'},
                            'java': {'bullets': ['Count with HashMap and sort entries.', 'Sort by freq desc then char asc.'], 'pseudocode': 'Map<Character,Integer> cnt=...; // count and sort by value then key\\n'},
                            'cpp': {'bullets': ['Count with unordered_map and sort vector of pairs.', 'Sort by freq desc then char asc.'], 'pseudocode': 'string frequency_sort(string s){ unordered_map<char,int> cnt; for(char c:s) cnt[c]++; vector<pair<char,int>> v(cnt.begin(),cnt.end()); sort(v.begin(),v.end(),[](auto &a,auto &b){ if(a.second!=b.second) return a.second>b.second; return a.first<b.first;}); string out=""; for(auto &p:v) out+=string(p.second,p.first); return out; }\\n'},
                        },

                        'merge_intervals': {
                            'python': {'bullets': ['Sort by start.', 'If current.start <= last.end, merge; else append.'], 'pseudocode': 'def merge_intervals(itv):\\n    itv.sort(key=lambda x: x[0])\\n    res=[]\\n    for s,e in itv:\\n        if not res or s > res[-1][1]: res.append([s,e])\\n        else: res[-1][1] = max(res[-1][1], e)\\n    return res\\n'},
                            'javascript': {'bullets': ['Sort and merge intervals similarly.'], 'pseudocode': 'function mergeIntervals(itv){ itv.sort((a,b)=>a[0]-b[0]); const res=[]; for(const [s,e] of itv){ if(!res.length||s>res[res.length-1][1]) res.push([s,e]); else res[res.length-1][1]=Math.max(res[res.length-1][1],e); } return res; }\\n'},
                            'java': {'bullets': ['Sort intervals and merge in one pass.'], 'pseudocode': 'Arrays.sort(intervals,(a,b)->a[0]-b[0]); List<int[]> res=new ArrayList<>(); for(int[] it:intervals){ if(res.isEmpty()||it[0]>res.get(res.size()-1)[1]) res.add(it); else res.get(res.size()-1)[1]=Math.max(res.get(res.size()-1)[1],it[1]); } return res.toArray(new int[res.size()][]);\\n'},
                            'cpp': {'bullets': ['Sort and merge intervals.'], 'pseudocode': 'vector<vector<int>> mergeIntervals(vector<vector<int>>& itv){ sort(itv.begin(),itv.end()); vector<vector<int>> res; for(auto &v:itv){ if(res.empty()||v[0]>res.back()[1]) res.push_back(v); else res.back()[1]=max(res.back()[1],v[1]); } return res; }\\n'},
                        },

                        'balanced_brackets': {
                            'python': {'bullets': ['Use a stack for opens.', 'Map closes to opens and match as you go.', 'Valid if stack empty at end.'], 'pseudocode': "pairs = {')':'(', ']':'[', '}':'{'}\\nstack = []\\nfor c in s:\\n    if c in "([{":\\n        stack.append(c)\\n    elif c in ")]}":\\n        if not stack or stack[-1] != pairs[c]:\\n            return False\\n        stack.pop()\\nreturn not stack\\n"},
                            'javascript': {'bullets': ['Use an array as a stack, map closing to opening char.'], 'pseudocode': 'function isValid(s){ const pairs={')':'(','}': '{','}': '{'}; const st=[]; for(const c of s){ if("([{".includes(c)) st.push(c); else{ if(!st.length||st.pop()!==pairs[c]) return false; } } return st.length===0; }\\n'},
                            'java': {'bullets': ['Use Deque/Stack to track opens.'], 'pseudocode': 'Deque<Character> st=new ArrayDeque<>(); Map<Character,Character> pairs=Map.of(')','(',']','[','}','{'); for(char c: s.toCharArray()){ if(pairs.containsValue(c)) st.push(c); else if(pairs.containsKey(c)){ if(st.isEmpty()||st.pop()!=pairs.get(c)) return false; } } return st.isEmpty();\\n'},
                            'cpp': {'bullets': ['Use vector<char> as stack and mapping for closes.'], 'pseudocode': 'bool isValid(string s){ unordered_map<char,char> pairs={{')','('},{']','['},{'}','{'}}; vector<char> st; for(char c:s){ if(c=='('||c=='['||c=='{') st.push_back(c); else{ if(st.empty()||st.back()!=pairs[c]) return false; st.pop_back(); } } return st.empty(); }\\n'},
                        },

                        'max_subarray': {
                            'python': {'bullets': ["Kadane's algorithm: track current and best sum.", 'current = max(x, current + x).'], 'pseudocode': 'best = cur = nums[0]\\nfor x in nums[1:]:\\n    cur = max(x, cur + x)\\n    best = max(best, cur)\\nreturn best\\n'},
                            'javascript': {'bullets': ["Kadane's algorithm"], 'pseudocode': 'function maxSubarray(nums){ let best=nums[0], cur=nums[0]; for(let i=1;i<nums.length;i++){ cur=Math.max(nums[i], cur+nums[i]); best=Math.max(best,cur); } return best; }\\n'},
                            'java': {'bullets': ["Kadane's algorithm"], 'pseudocode': 'int maxSubarray(int[] nums){ int best=nums[0], cur=nums[0]; for(int i=1;i<nums.length;i++){ cur=Math.max(nums[i], cur+nums[i]); best=Math.max(best,cur); } return best; }\\n'},
                            'cpp': {'bullets': ["Kadane's algorithm"], 'pseudocode': 'int maxSubarray(vector<int>& nums){ int best=nums[0], cur=nums[0]; for(size_t i=1;i<nums.size();++i){ cur=max(nums[i], cur+nums[i]); best=max(best,cur); } return best; }\\n'},
                        },

                        'product_except_self': {
                            'python': {'bullets': ['Compute prefix products then multiply by suffix pass.', 'O(n) time, O(1) extra arrays aside from output.'], 'pseudocode': 'n=len(nums); res=[1]*n\\npre=1\\nfor i in range(n): res[i]=pre; pre*=nums[i]\\nsuf=1\\nfor i in range(n-1,-1,-1): res[i]*=suf; suf*=nums[i]\\nreturn res\\n'},
                            'javascript': {'bullets': ['Compute prefix and suffix products.'], 'pseudocode': 'function productExceptSelf(nums){ const n=nums.length; const res=Array(n).fill(1); let pre=1; for(let i=0;i<n;i++){ res[i]=pre; pre*=nums[i]; } let suf=1; for(let i=n-1;i>=0;i--){ res[i]*=suf; suf*=nums[i]; } return res; }\\n'},
                            'java': {'bullets': ['Compute prefix and suffix without division.'], 'pseudocode': 'int[] productExceptSelf(int[] nums){ int n=nums.length; int[] res=new int[n]; Arrays.fill(res,1); int pre=1; for(int i=0;i<n;i++){ res[i]=pre; pre*=nums[i]; } int suf=1; for(int i=n-1;i>=0;i--){ res[i]*=suf; suf*=nums[i]; } return res; }\\n'},
                            'cpp': {'bullets': ['Compute prefix and suffix.'], 'pseudocode': 'vector<int> productExceptSelf(vector<int>& nums){ int n=nums.size(); vector<int> res(n,1); int pre=1; for(int i=0;i<n;i++){ res[i]=pre; pre*=nums[i]; } int suf=1; for(int i=n-1;i>=0;i--){ res[i]*=suf; suf*=nums[i]; } return res; }\\n'},
                        },

                        'three_sum': {
                            'python': {'bullets': ['Sort array; fix i; two-pointer on [i+1..].', 'Skip duplicates at i and while moving pointers.'], 'pseudocode': 'nums.sort()\\nres=[]\\nfor i,x in enumerate(nums):\\n  if i and nums[i]==nums[i-1]: continue\\n  l,r=i+1,len(nums)-1\\n  while l<r:\\n    s=x+nums[l]+nums[r]\
        with open(cpp_file, 'w') as f:
                            'javascript': {'bullets': ['Sort and use two-pointer technique.'], 'pseudocode': 'function threeSum(nums){ nums.sort((a,b)=>a-b); const res=[]; for(let i=0;i<nums.length;i++){ if(i&&nums[i]==nums[i-1]) continue; let l=i+1,r=nums.length-1; while(l<r){ const s=nums[i]+nums[l]+nums[r]; if(s==0){ res.push([nums[i],nums[l],nums[r]]); l++; r--; while(l<r&&nums[l]==nums[l-1]) l++; while(l<r&&nums[r]==nums[r+1]) r--; } else if(s<0) l++; else r--; } } return res; }\\n'},
                            'java': {'bullets': ['Sort and two-pointer approach.'], 'pseudocode': 'List<List<Integer>> threeSum(int[] nums){ Arrays.sort(nums); List<List<Integer>> res=new ArrayList<>(); for(int i=0;i<nums.length;i++){ if(i>0&&nums[i]==nums[i-1]) continue; int l=i+1,r=nums.length-1; while(l<r){ int s=nums[i]+nums[l]+nums[r]; if(s==0){ res.add(Arrays.asList(nums[i],nums[l],nums[r])); l++; r--; while(l<r&&nums[l]==nums[l-1]) l++; while(l<r&&nums[r]==nums[r+1]) r--; } else if(s<0) l++; else r--; } } return res; }\\n'},
                            'cpp': {'bullets': ['Sort and two-pointer approach.'], 'pseudocode': 'vector<vector<int>> threeSum(vector<int>& nums){ sort(nums.begin(),nums.end()); vector<vector<int>> res; for(int i=0;i<nums.size();++i){ if(i&&nums[i]==nums[i-1]) continue; int l=i+1,r=nums.size()-1; while(l<r){ int s=nums[i]+nums[l]+nums[r]; if(s==0){ res.push_back({nums[i],nums[l],nums[r]}); l++; r--; while(l<r&&nums[l]==nums[l-1]) l++; while(l<r&&nums[r]==nums[r+1]) r--; } else if(s<0) l++; else r--; } } return res; }\\n'},
                        },

                        'two_sum_sorted': {
                            'python': {'bullets': ['Use two pointers from ends.', 'Move left if sum<target else move right.'], 'pseudocode': 'l,r=0,len(nums)-1\\nwhile l<r:\\n  s=nums[l]+nums[r]\\n  if s==target: return [l,r]\\n  if s<target: l+=1\\n  else: r-=1\\nreturn [-1,-1]\\n'},
                            'javascript': {'bullets': ['Use two pointers.'], 'pseudocode': 'function twoSumSorted(nums,target){ let l=0,r=nums.length-1; while(l<r){ const s=nums[l]+nums[r]; if(s==target) return [l,r]; if(s<target) l++; else r--; } return [-1,-1]; }\\n'},
                            'java': {'bullets': ['Two-pointer on sorted array.'], 'pseudocode': 'int[] twoSumSorted(int[] nums,int target){ int l=0,r=nums.length-1; while(l<r){ int s=nums[l]+nums[r]; if(s==target) return new int[]{l,r}; if(s<target) l++; else r--; } return new int[]{-1,-1}; }\\n'},
                            'cpp': {'bullets': ['Two-pointer technique.'], 'pseudocode': 'vector<int> twoSumSorted(vector<int>& nums,int target){ int l=0,r=nums.size()-1; while(l<r){ int s=nums[l]+nums[r]; if(s==target) return {l,r}; if(s<target) l++; else r--; } return {-1,-1}; }\\n'},
                        },

                        'longest_substring_without_repeating_characters': {
                            'python': {'bullets': ['Sliding window with last seen position.', 'Move left to max(left, last[c]+1).'], 'pseudocode': 'last={}; left=0; best=0\\nfor i,c in enumerate(s):\\n  if c in last: left=max(left,last[c]+1)\\n  last[c]=i\\  best=max(best,i-left+1)\\nreturn best\\n'},
                            'javascript': {'bullets': ['Sliding window using a Map for last-seen positions.'], 'pseudocode': 'function lengthOfLongestSubstring(s){ const last=new Map(); let left=0,best=0; for(let i=0;i<s.length;i++){ if(last.has(s[i])) left=Math.max(left,last.get(s[i])+1); last.set(s[i],i); best=Math.max(best,i-left+1); } return best; }\\n'},
                            'java': {'bullets': ['Sliding window with array/map for last seen.'], 'pseudocode': 'int lengthOfLongestSubstring(String s){ int[] last=new int[128]; Arrays.fill(last,-1); int left=0,best=0; for(int i=0;i<s.length();i++){ left=Math.max(left,last[s.charAt(i)]+1); last[s.charAt(i)]=i; best=Math.max(best,i-left+1); } return best; }\\n'},
                            'cpp': {'bullets': ['Sliding window with unordered_map for last seen.'], 'pseudocode': 'int lengthOfLongestSubstring(string s){ unordered_map<char,int> last; int left=0,best=0; for(int i=0;i<s.size();i++){ if(last.count(s[i])) left=max(left,last[s[i]]+1); last[s[i]]=i; best=max(best,i-left+1); } return best; }\\n'},
                        },

                        'group_anagrams': {
                            'python': {'bullets': ['Key by sorted word or 26-letter counts.', 'Sort groups for deterministic output.'], 'pseudocode': 'from collections import defaultdict\\nmp=defaultdict(list)\\nfor w in strs:\\n  key="".join(sorted(w))\\n  mp[key].append(w)\\nreturn [sorted(v) for v in sorted(mp.values(), key=lambda x: (len(x), x))]\\n'},
                            'javascript': {'bullets': ['Key by sorted word or char counts.'], 'pseudocode': 'function groupAnagrams(strs){ const mp=new Map(); for(const w of strs){ const key=w.split("").sort().join(""); if(!mp.has(key)) mp.set(key,[]); mp.get(key).push(w); } return [...mp.values()].map(g=>g.sort()); }\\n'},
                            'java': {'bullets': ['Use sort as key or frequency signature.'], 'pseudocode': 'Map<String,List<String>> mp=new HashMap<>(); for(String w: strs){ char[] ch=w.toCharArray(); Arrays.sort(ch); String key=new String(ch); mp.computeIfAbsent(key,k->new ArrayList<>()).add(w);} return new ArrayList<>(mp.values());\\n'},
                            'cpp': {'bullets': ['Use sorted string or count key.'], 'pseudocode': 'vector<vector<string>> groupAnagrams(vector<string>& strs){ unordered_map<string,vector<string>> mp; for(auto &w:strs){ string key=w; sort(key.begin(),key.end()); mp[key].push_back(w); } vector<vector<string>> res; for(auto &p:mp) { sort(p.second.begin(),p.second.end()); res.push_back(p.second); } return res; }\\n'},
                        },

                        'top_k_frequent': {
                            'python': {'bullets': ['Use Counter to count, then sort by -freq.', 'Return ascending for determinism if same freq.'], 'pseudocode': 'from collections import Counter\\ncounts=Counter(nums)\\nitems=sorted(counts.items(), key=lambda kv:(-kv[1], kv[0]))\\nreturn [x for x,_ in items[:k]]\\n'},
                            'javascript': {'bullets': ['Count then sort or use heap.'], 'pseudocode': 'function topKFrequent(nums,k){ const counts=new Map(); for(const x of nums) counts.set(x,(counts.get(x)||0)+1); return [...counts.entries()].sort((a,b)=>b[1]-a[1]||a[0]-b[0]).slice(0,k).map(x=>x[0]); }\\n'},
                            'java': {'bullets': ['Count then use PriorityQueue or sort entries.'], 'pseudocode': 'Map<Integer,Integer> cnt=new HashMap<>(); for(int x:nums) cnt.put(x,cnt.getOrDefault(x,0)+1); List<Map.Entry<Integer,Integer>> items=new ArrayList<>(cnt.entrySet()); items.sort((a,b)->b.getValue()-a.getValue()); return items.subList(0,k).stream().map(Map.Entry::getKey).collect(Collectors.toList());\\n'},
                            'cpp': {'bullets': ['Count then sort vector of pairs or use heap.'], 'pseudocode': 'vector<int> topKFrequent(vector<int>& nums,int k){ unordered_map<int,int> cnt; for(int x:nums) cnt[x]++; vector<pair<int,int>> v(cnt.begin(),cnt.end()); sort(v.begin(),v.end(),[](auto &a,auto &b){ return a.second>b.second;}); vector<int> res; for(int i=0;i<k;i++) res.push_back(v[i].first); return res; }\\n'},
                        },

                        'kth_largest': {
                            'python': {'bullets': ['Quickselect or heap; quickselect is average O(n).'], 'pseudocode': '# quickselect partition around pivot to find index n-k\\n'},
                            'javascript': {'bullets': ['Use quickselect or heap.'], 'pseudocode': '/* quickselect or heap approach */\\n'},
                            'java': {'bullets': ['Use quickselect or PriorityQueue.'], 'pseudocode': '/* quickselect or heap */\\n'},
                            'cpp': {'bullets': ['Use nth_element or quickselect.'], 'pseudocode': '/* use nth_element or quickselect */\\n'},
                        },

                        'binary_search': {
                            'python': {'bullets': ['Classic low<=high, mid=(l+r)//2.', 'Compare and shrink range.'], 'pseudocode': 'l,r=0,len(nums)-1\\nwhile l<=r:\\n  m=(l+r)//2\\n  if nums[m]==target: return m\\n  if nums[m]<target: l=m+1\\n  else: r=m-1\\nreturn -1\\n'},
                            'javascript': {'bullets': ['Classic binary search.'], 'pseudocode': 'function binarySearch(arr,target){ let l=0,r=arr.length-1; while(l<=r){ const m=(l+r)>>1; if(arr[m]==target) return m; if(arr[m]<target) l=m+1; else r=m-1; } return -1;}\\n'},
                            'java': {'bullets': ['Classic binary search.'], 'pseudocode': 'int binarySearch(int[] nums,int target){ int l=0,r=nums.length-1; while(l<=r){ int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1;} return -1; }\\n'},
                            'cpp': {'bullets': ['Classic binary search.'], 'pseudocode': 'int binarySearch(vector<int>& nums,int target){ int l=0,r=nums.size()-1; while(l<=r){ int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return -1; }\\n'},
                        },

                        'search_rotated_sorted_array': {
                            'python': {'bullets': ['One half is sorted at each step.', 'Check which half target lies in and adjust.'], 'pseudocode': 'l,r=0,len(nums)-1\\nwhile l<=r:\\n  m=(l+r)//2\\n  if nums[m]==target: return m\\n  if nums[l]<=nums[m]:\\n    if nums[l]<=target<nums[m]: r=m-1\\n    else: l=m+1\\n  else:\\n    if nums[m]<target<=nums[r]: l=m+1\\n    else: r=m-1\\nreturn -1\\n'},
                            'javascript': {'bullets': ['Same logic as Python but watch edge cases.'], 'pseudocode': 'function searchRotated(nums,target){ let l=0,r=nums.length-1; while(l<=r){ let m=(l+r)>>1; if(nums[m]==target) return m; if(nums[l]<=nums[m]){ if(nums[l]<=target&&target<nums[m]) r=m-1; else l=m+1; } else{ if(nums[m]<target&&target<=nums[r]) l=m+1; else r=m-1; } } return -1; }\\n'},
                            'java': {'bullets': ['Check sorted half each iteration.'], 'pseudocode': 'int search(int[] nums,int target){ int l=0,r=nums.length-1; while(l<=r){ int m=(l+r)/2; if(nums[m]==target) return m; if(nums[l]<=nums[m]){ if(nums[l]<=target&&target<nums[m]) r=m-1; else l=m+1; } else{ if(nums[m]<target&&target<=nums[r]) l=m+1; else r=m-1; } } return -1; }\\n'},
                            'cpp': {'bullets': ['Check which half is sorted.'], 'pseudocode': 'int search(vector<int>& nums,int target){ int l=0,r=nums.size()-1; while(l<=r){ int m=(l+r)/2; if(nums[m]==target) return m; if(nums[l]<=nums[m]){ if(nums[l]<=target&&target<nums[m]) r=m-1; else l=m+1; } else{ if(nums[m]<target&&target<=nums[r]) l=m+1; else r=m-1; } } return -1; }\\n'},
                        },

                        'max_product_subarray': {
                            'python': {'bullets': ['Track both max and min due to negatives.', 'Swap when x<0.'], 'pseudocode': 'best=hi=lo=nums[0]\\nfor x in nums[1:]:\\n  if x<0: hi,lo=lo,hi\\n  hi=max(x, hi*x); lo=min(x, lo*x)\\n  best=max(best, hi)\\nreturn best\\n'},
                            'javascript': {'bullets': ['Track max and min at each step.'], 'pseudocode': 'function maxProduct(nums){ let best=nums[0], hi=nums[0], lo=nums[0]; for(let i=1;i<nums.length;i++){ const x=nums[i]; if(x<0) [hi,lo]=[lo,hi]; hi=Math.max(x,hi*x); lo=Math.min(x,lo*x); best=Math.max(best,hi);} return best; }\\n'},
                            'java': {'bullets': ['Track two values (max/min) across iteration.'], 'pseudocode': 'int maxProduct(int[] nums){ int best=nums[0], hi=nums[0], lo=nums[0]; for(int i=1;i<nums.length;i++){ int x=nums[i]; if(x<0){ int t=hi; hi=lo; lo=t; } hi=Math.max(x,hi*x); lo=Math.min(x,lo*x); best=Math.max(best,hi);} return best; }\\n'},
                            'cpp': {'bullets': ['Track max/min due to negatives.'], 'pseudocode': 'int maxProduct(vector<int>& nums){ int best=nums[0], hi=nums[0], lo=nums[0]; for(size_t i=1;i<nums.size();++i){ int x=nums[i]; if(x<0) swap(hi,lo); hi=max(x,hi*x); lo=min(x,lo*x); best=max(best,hi);} return best; }\\n'},
                        },

                        'coin_change': {
                            'python': {'bullets': ['Bottom-up DP: dp[a]=min(dp[a], dp[a-c]+1).', 'Initialize dp with inf and dp[0]=0.'], 'pseudocode': 'dp=[10**9]*(amount+1); dp[0]=0\\nfor c in coins:\\n  for a in range(c, amount+1):\\n    dp[a]=min(dp[a], dp[a-c]+1)\\nreturn dp[amount] if dp[amount]<10**9 else -1\\n'},
                            'javascript': {'bullets': ['Bottom-up DP approach.'], 'pseudocode': 'function coinChange(coins,amount){ const INF=1e9; const dp=new Array(amount+1).fill(INF); dp[0]=0; for(const c of coins) for(let a=c;a<=amount;a++) dp[a]=Math.min(dp[a], dp[a-c]+1); return dp[amount]<INF?dp[amount]:-1; }\\n'},
                            'java': {'bullets': ['Use DP with large initial sentinel.'], 'pseudocode': 'int coinChange(int[] coins,int amount){ int INF=1_000_000_000; int[] dp=new int[amount+1]; Arrays.fill(dp,INF); dp[0]=0; for(int c:coins) for(int a=c;a<=amount;a++) dp[a]=Math.min(dp[a], dp[a-c]+1); return dp[amount]<INF?dp[amount]:-1; }\\n'},
                            'cpp': {'bullets': ['Bottom-up DP.'], 'pseudocode': 'int coinChange(vector<int>& coins,int amount){ const int INF=1e9; vector<int> dp(amount+1,INF); dp[0]=0; for(int c:coins) for(int a=c;a<=amount;a++) dp[a]=min(dp[a], dp[a-c]+1); return dp[amount]<INF?dp[amount]:-1; }\\n'},
                        },

                        'climb_stairs': {
                            'python': {'bullets': ['Fibonacci: f(n)=f(n-1)+f(n-2).', 'Iterative O(1) space.'], 'pseudocode': 'a,b=1,1\\nfor _ in range(n-1): a,b=b,a+b\\nreturn b if n>0 else 1\\n'},
                            'javascript': {'bullets': ['Fibonacci relation; iterative approach works.'], 'pseudocode': 'function climb_stairs(n){ let a=1,b=1; for(let i=0;i<n-1;i++){ [a,b]=[b,a+b]; } return n>0?b:1; }\\n'},
                            'java': {'bullets': ['Fibonacci relation; iterative approach works.'], 'pseudocode': 'int climbStairs(int n){ int a=1,b=1; for(int i=0;i<n-1;i++){ int t=b; b=a+b; a=t; } return n>0?b:1; }\\n'},
                            'cpp': {'bullets': ['Fibonacci relation; iterative approach works.'], 'pseudocode': 'int climbStairs(int n){ int a=1,b=1; for(int i=0;i<n-1;i++){ int t=b; b=a+b; a=t; } return n>0?b:1; }\\n'},
                        },

                        'min_window_substring': {
                            'python': {'bullets': ['Sliding window with need/have counts.', 'Expand right until valid, then shrink left.'], 'pseudocode': '# Use Counter for t; track formed == required distinct chars.\\n'},
                            'javascript': {'bullets': ['Sliding window with counts.'], 'pseudocode': '/* Sliding window with need/have counts */\\n'},
                            'java': {'bullets': ['Sliding window with counts.'], 'pseudocode': '/* Sliding window with need/have counts */\\n'},
                            'cpp': {'bullets': ['Sliding window with counts.'], 'pseudocode': '/* Sliding window with need/have counts */\\n'},
                        },

                        'longest_palindromic_substring': {
                            'python': {'bullets': ['Expand-around-center for each i (odd and even).'], 'pseudocode': 'def expand(l,r):\\n  while l>=0 and r<len(s) and s[l]==s[r]: l-=1; r+=1\\n  return l+1,r-1\\n# track best window\\n'},
                            'javascript': {'bullets': ['Expand around centers.'], 'pseudocode': '/* expand around center */\\n'},
                            'java': {'bullets': ['Expand around centers.'], 'pseudocode': '/* expand-around-center */\\n'},
                            'cpp': {'bullets': ['Expand around centers.'], 'pseudocode': '/* expand-around-center */\\n'},
                        },

                        'rotate_matrix': {
                            'python': {'bullets': ['Transpose then reverse each row (in-place) or build new using zip.'], 'pseudocode': 'return [list(row)[::-1] for row in zip(*matrix)]\\n'},
                            'javascript': {'bullets': ['Transpose then reverse rows or build new array.'], 'pseudocode': '/* transpose then reverse each row */\\n'},
                            'java': {'bullets': ['Transpose and reverse or swap indices in-place.'], 'pseudocode': '/* transpose and reverse rows */\\n'},
                            'cpp': {'bullets': ['Transpose and reverse rows.'], 'pseudocode': '/* transpose and reverse */\\n'},
                        },

                        'number_of_islands': {
                            'python': {'bullets': ['Scan grid; when you see "1", DFS/BFS to mark all connected land to "0".', 'Use bounds checks and 4-direction neighbors.'], 'pseudocode': 'def dfs(r,c):\\n  if out_of_bounds or grid[r][c]!="1": return\\n  grid[r][c]="0"\\n  for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]: dfs(r+dr,c+dc)\\ncount=0\\nfor r in range(R):\\n  for c in range(C):\\n    if grid[r][c]=="1": count+=1; dfs(r,c)\\nreturn count\\n'},
                            'javascript': {'bullets': ['Scan grid; use DFS/BFS to mark visited cells.', 'Be careful with in-place modification vs copying.'], 'pseudocode': 'function numIslands(grid){ const R=grid.length, C=grid[0].length; function dfs(r,c){ if(r<0||c<0||r>=R||c>=C||grid[r][c]==="0") return; grid[r][c]="0"; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>dfs(r+dr,c+dc)); } let count=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(grid[r][c]==="1"){count++; dfs(r,c);} return count; }\\n'},
                            'java': {'bullets': ['Scan grid; perform DFS/BFS using recursion or stack.', 'Mark visited cells to avoid recounting.'], 'pseudocode': 'public int numIslands(char[][] grid){ int R=grid.length, C=grid[0].length; int count=0; for(int r=0;r<R;r++) for(int c=0;c<C;c++) if(grid[r][c]==\'1\'){ dfs(grid,r,c); count++; } return count; }\\n'},
                            'cpp': {'bullets': ['Use DFS/BFS and mark visited cells.', 'Watch recursion depth for large grids; consider iterative stack.'], 'pseudocode': 'int numIslands(vector<vector<char>>& grid){ int R=grid.size(), C=grid[0].size(); function<void(int,int)> dfs=[&](int r,int c){ if(r<0||c<0||r>=R||c>=C||grid[r][c]==\'0\') return; grid[r][c]=\'0\'; dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1); }; int count=0; for(int r=0;r<R;r++) for(int c=0;c<C;c++) if(grid[r][c]==\'1\'){count++; dfs(r,c);} return count; }\\n'},
                        },
                    }
            f.write(test_code)
        
        # Compile
        compile_proc = subprocess.run(
            ['g++', '-std=c++17', cpp_file, '-o', exe_file],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if compile_proc.returncode != 0:
            raise RuntimeError(f'C++ compilation error: {compile_proc.stderr}')
        
        # Run
        run_proc = subprocess.run(
            [exe_file],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if run_proc.returncode != 0:
            raise RuntimeError(f'C++ runtime error: {run_proc.stderr}')
        
        # Parse result
        output = run_proc.stdout
        for line in output.split('\n'):
            if line.startswith('RESULT:'):
                result_str = line[7:].strip()
                # Try to parse as number
                try:
                    if '.' in result_str:
                        result = float(result_str)
                    else:
                        result = int(result_str)
                except:
                    result = result_str
                return result, output, run_proc.stderr
        
        raise RuntimeError(f'Could not find RESULT in output: {output}')
    finally:
        import shutil
        shutil.rmtree(temp_dir, ignore_errors=True)


LANGUAGE_EXECUTORS = {
    'python': execute_python,
    'javascript': execute_javascript,
    'java': execute_java,
    'cpp': execute_cpp
}


PROBLEMS = {
    'summation': {
        'name': 'summation',
        'title': 'Sum of Two Integers',
        'description': 'Implement summation(a, b) that returns the sum of two integers.',
        'signature': 'def summation(a, b):',
        'stubs': {
            'python': 'def summation(a, b):\n    # Write your code here\n    pass\n',
            'javascript': 'function summation(a, b) {\n    // Write your code here\n}\n',
            'java': 'public class Solution {\n    public int summation(int a, int b) {\n        // Write your code here\n        return 0;\n    }\n}\n',
            'cpp': 'int summation(int a, int b) {\n    // Write your code here\n    return 0;\n}\n'
        },
        'tests': [
            {'args': (2, 3), 'expected': 5},
            {'args': (-1, 1), 'expected': 0},
            {'args': (0, 0), 'expected': 0},
        ]
    },
    'palindrome': {
        'name': 'palindrome',
        'title': 'Is Palindrome',
        'description': 'Implement is_palindrome(s) that checks if a string is a palindrome (ignore non-alphanumeric, case-insensitive).',
        'signature': 'def is_palindrome(s):',
        'stubs': {
            'python': 'def is_palindrome(s):\n    # Write your code here\n    pass\n',
            'javascript': 'function is_palindrome(s) {\n    // Write your code here\n}\n',
            'java': 'public class Solution {\n    public boolean is_palindrome(String s) {\n        // Write your code here\n        return false;\n    }\n}\n',
            'cpp': 'bool is_palindrome(string s) {\n    // Write your code here\n    return false;\n}\n'
        },
        'tests': [
            {'args': ("A man, a plan, a canal: Panama",), 'expected': True},
            {'args': ("race a car",), 'expected': False},
            {'args': ("",), 'expected': True},
        ]
    },
    'second_largest': {
        'name': 'second_largest',
        'title': 'Second Largest',
        'description': 'Implement second_largest(nums) that returns the second largest distinct integer, or None if it doesn\'t exist.',
        'signature': 'def second_largest(nums):',
        'tests': [
            {'args': ([2, 3, 1],), 'expected': 2},
            {'args': ([5, 5, 5],), 'expected': None},
            {'args': ([-1, -2, -3],), 'expected': -2},
        ]
    },
    'frequency_sort': {
        'name': 'frequency_sort',
        'title': 'Frequency Sort',
        'description': 'Implement frequency_sort(s) that sorts characters by frequency (desc), then alphabetically (asc).',
        'signature': 'def frequency_sort(s):',
        'tests': [
            {'args': ("tree",), 'expected': "eert"},
            {'args': ("cccaaa",), 'expected': "aaaccc"},
            {'args': ("",), 'expected': ""},
        ]
    },
    'merge_intervals': {
        'name': 'merge_intervals',
        'title': 'Merge Intervals',
        'description': 'Implement merge_intervals(intervals) that merges overlapping intervals.',
        'signature': 'def merge_intervals(intervals):',
        'tests': [
            {'args': ([[1,3],[2,6],[8,10],[15,18]],), 'expected': [[1,6],[8,10],[15,18]]},
            {'args': ([[1,4],[4,5]],), 'expected': [[1,5]]},
            {'args': ([],), 'expected': []},
        ]
    },
    'two_sum': {
        'name': 'two_sum',
        'title': 'Two Sum',
        'description': 'Implement two_sum(nums, target) that returns indices [i,j] summing to target, or [-1,-1].',
        'signature': 'def two_sum(nums, target):',
        'stubs': {
            'python': 'def two_sum(nums, target):\n    # Write your code here\n    pass\n',
            'javascript': 'function two_sum(nums, target) {\n    // Write your code here\n}\n',
            'java': 'public class Solution {\n    public int[] two_sum(int[] nums, int target) {\n        // Write your code here\n        return new int[]{-1, -1};\n    }\n}\n',
            'cpp': 'vector<int> two_sum(vector<int>& nums, int target) {\n    // Write your code here\n    return {-1, -1};\n}\n'
        },
        'tests': [
            {'args': ([2,7,11,15], 9), 'expected': [0,1]},
            {'args': ([3,2,4], 6), 'expected': [1,2]},
            {'args': ([3,3], 6), 'expected': [0,1]},
            {'args': ([1,2,3], 10), 'expected': [-1,-1]},
        ]
    },
    'balanced_brackets': {
        'name': 'balanced_brackets',
        'title': 'Balanced Brackets',
        'description': 'Implement balanced_brackets(s) that checks if brackets are balanced: (), {}, []',
        'signature': 'def balanced_brackets(s):',
        'tests': [
            {'args': ("()[]{}",), 'expected': True},
            {'args': ("(]",), 'expected': False},
            {'args': ("([{}])",), 'expected': True},
        ]
    },
    # --- Added harder problems below ---
    'max_subarray': {
        'name': 'max_subarray',
        'title': 'Maximum Subarray Sum',
        'description': 'Implement max_subarray(nums) returning the maximum possible subarray sum (Kadane\'s algorithm).',
        'signature': 'def max_subarray(nums):',
        'tests': [
            {'args': ([-2,1,-3,4,-1,2,1,-5,4],), 'expected': 6},  # [4,-1,2,1]
            {'args': ([1],), 'expected': 1},
            {'args': ([-1,-2,-3],), 'expected': -1},
        ]
    },
    'product_except_self': {
        'name': 'product_except_self',
        'title': 'Product of Array Except Self',
        'description': 'Implement product_except_self(nums) without using division, return an array where each element is the product of all other elements.',
        'signature': 'def product_except_self(nums):',
        'tests': [
            {'args': ([1,2,3,4],), 'expected': [24,12,8,6]},
            {'args': ([0,1,2,3],), 'expected': [6,0,0,0]},
        ]
    },
    'three_sum': {
        'name': 'three_sum',
        'title': '3Sum',
        'description': 'Implement three_sum(nums) returning a list of unique triplets [a,b,c] such that a+b+c=0. Order of triplets and elements within triplets does not matter.',
        'signature': 'def three_sum(nums):',
        'tests': [
            {'args': ([-1,0,1,2,-1,-4],), 'expected': [[-1,-1,2],[-1,0,1]]},
            {'args': ([0,1,1],), 'expected': []},
        ]
    },
    'two_sum_sorted': {
        'name': 'two_sum_sorted',
        'title': 'Two Sum II (Sorted)',
        'description': 'Implement two_sum_sorted(nums, target) where nums is sorted ascending, return 0-based indices [i,j] or [-1,-1].',
        'signature': 'def two_sum_sorted(nums, target):',
        'tests': [
            {'args': ([2,7,11,15], 9), 'expected': [0,1]},
            {'args': ([1,2,3,4,4,9], 8), 'expected': [3,4]},
        ]
    },
    'longest_substring_without_repeating_characters': {
        'name': 'longest_substring_without_repeating_characters',
        'title': 'Longest Substring Without Repeating Characters',
        'description': 'Implement longest_substring_without_repeating_characters(s) and return its length.',
        'signature': 'def longest_substring_without_repeating_characters(s):',
        'tests': [
            {'args': ("abcabcbb",), 'expected': 3},
            {'args': ("bbbbb",), 'expected': 1},
            {'args': ("pwwkew",), 'expected': 3},
        ]
    },
    'group_anagrams': {
        'name': 'group_anagrams',
        'title': 'Group Anagrams',
        'description': 'Implement group_anagrams(strs) that groups words that are anagrams. Return groups sorted internally and externally for determinism.',
        'signature': 'def group_anagrams(strs):',
        'tests': [
            {'args': ((["eat","tea","tan","ate","nat","bat"]).copy(),), 'expected': [["ate","eat","tea"],["nat","tan"],["bat"]]},
        ]
    },
    'top_k_frequent': {
        'name': 'top_k_frequent',
        'title': 'Top K Frequent Elements',
        'description': 'Implement top_k_frequent(nums, k) returning a list of k most frequent elements (any order acceptable, but sort ascending for determinism).',
        'signature': 'def top_k_frequent(nums, k):',
        'tests': [
            {'args': ([1,1,1,2,2,3], 2), 'expected': [1,2]},
            {'args': ([4,1,-1,2,-1,2,3], 2), 'expected': [-1,2]},
        ]
    },
    'kth_largest': {
        'name': 'kth_largest',
        'title': 'Kth Largest Element',
        'description': 'Implement kth_largest(nums, k) returning the k-th largest element in the array.',
        'signature': 'def kth_largest(nums, k):',
        'tests': [
            {'args': ([3,2,1,5,6,4], 2), 'expected': 5},
            {'args': ([3,2,3,1,2,4,5,5,6], 4), 'expected': 4},
        ]
    },
    'binary_search': {
        'name': 'binary_search',
        'title': 'Binary Search',
        'description': 'Implement binary_search(nums, target) returning index or -1. nums is sorted ascending.',
        'signature': 'def binary_search(nums, target):',
        'tests': [
            {'args': ([1,2,3,4,5], 4), 'expected': 3},
            {'args': ([1,2,3,4,5], 6), 'expected': -1},
        ]
    },
    'search_rotated_sorted_array': {
        'name': 'search_rotated_sorted_array',
        'title': 'Search in Rotated Sorted Array',
        'description': 'Implement search_rotated_sorted_array(nums, target) returning index or -1.',
        'signature': 'def search_rotated_sorted_array(nums, target):',
        'tests': [
            {'args': ([4,5,6,7,0,1,2], 0), 'expected': 4},
            {'args': ([4,5,6,7,0,1,2], 3), 'expected': -1},
        ]
    },
    'max_product_subarray': {
        'name': 'max_product_subarray',
        'title': 'Maximum Product Subarray',
        'description': 'Implement max_product_subarray(nums) returning the maximum product of a contiguous subarray.',
        'signature': 'def max_product_subarray(nums):',
        'tests': [
            {'args': ([2,3,-2,4],), 'expected': 6},
            {'args': ([-2,0,-1],), 'expected': 0},
        ]
    },
    'coin_change': {
        'name': 'coin_change',
        'title': 'Coin Change (Min Coins)',
        'description': 'Implement coin_change(coins, amount) to return the minimum number of coins to make up amount, or -1 if not possible.',
        'signature': 'def coin_change(coins, amount):',
        'tests': [
            {'args': ([1,2,5], 11), 'expected': 3},
            {'args': ([2], 3), 'expected': -1},
        ]
    },
    'climb_stairs': {
        'name': 'climb_stairs',
        'title': 'Climbing Stairs',
        'description': 'Implement climb_stairs(n) where you can climb 1 or 2 steps at a time; return number of distinct ways.',
        'signature': 'def climb_stairs(n):',
        'tests': [
            {'args': (2,), 'expected': 2},
            {'args': (3,), 'expected': 3},
        ]
    },
    'min_window_substring': {
        'name': 'min_window_substring',
        'title': 'Minimum Window Substring',
        'description': 'Implement min_window_substring(s, t) returning the smallest substring of s that contains all chars of t (with multiplicity). Return "" if none.',
        'signature': 'def min_window_substring(s, t):',
        'tests': [
            {'args': ("ADOBECODEBANC", "ABC"), 'expected': "BANC"},
            {'args': ("a", "aa"), 'expected': ""},
        ]
    },
    'longest_palindromic_substring': {
        'name': 'longest_palindromic_substring',
        'title': 'Longest Palindromic Substring',
        'description': 'Implement longest_palindromic_substring(s) returning one longest palindromic substring.',
        'signature': 'def longest_palindromic_substring(s):',
        'tests': [
            {'args': ("babad",), 'expected': "bab"},
            {'args': ("cbbd",), 'expected': "bb"},
        ]
    },
    'rotate_matrix': {
        'name': 'rotate_matrix',
        'title': 'Rotate Matrix 90°',
        'description': 'Implement rotate_matrix(matrix) to return a new matrix rotated 90 degrees clockwise.',
        'signature': 'def rotate_matrix(matrix):',
        'tests': [
            {'args': ([[1,2,3],[4,5,6],[7,8,9]],), 'expected': [[7,4,1],[8,5,2],[9,6,3]]},
        ]
    },
    'number_of_islands': {
        'name': 'number_of_islands',
        'title': 'Number of Islands',
        'description': 'Implement number_of_islands(grid) where grid is a list of list of "1" and "0"; return count of islands (4-direction).',
        'signature': 'def number_of_islands(grid):',
        'tests': [
            {'args': (([["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]),), 'expected': 3},
        ]
    },
}

# Optional per-problem hints shown in the UI
HINTS = {
    'summation': {
        'python': {
            'bullets': [
                'Inputs are integers; just return a + b.',
                'No overflow concerns in Python ints.',
            ],
            'pseudocode': 'def summation(a, b):\\n    return a + b\\n'
        },
        'javascript': {
            'bullets': [
                'Be careful with implicit type coercion; ensure inputs are numbers.',
                'Return a + b; Node.js will handle number addition.',
            ],
            'pseudocode': 'function summation(a, b) {\\n    return a + b;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Use primitive ints to avoid boxing overhead.',
                'Return a + b from the method.',
            ],
            'pseudocode': 'public int summation(int a, int b) {\\n    return a + b;\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Use int (or long) depending on expected range.',
                'Return a + b from the function.',
            ],
            'pseudocode': 'int summation(int a, int b) {\\n    return a + b;\\n}\\n'
        },
    },
    'palindrome': {
        'python': {
            'bullets': [
                'Filter to alphanumeric using str.isalnum and lowercase.',
                'Use two pointers i/j; compare and move inward.',
                'Empty string is a palindrome.',
            ],
            'pseudocode': 'def is_palindrome(s):\\n    t = [c.lower() for c in s if c.isalnum()]\\n    i, j = 0, len(t)-1\\n    while i < j:\\n        if t[i] != t[j]:\\n            return False\\n        i += 1; j -= 1\\n    return True\\n'
        },
        'javascript': {
            'bullets': [
                'Normalize with regex: keep alphanumeric and toLowerCase().',
                'Use two indices or reverse the string and compare.',
            ],
            'pseudocode': 'function is_palindrome(s) {\\n    const t = s.replace(/[^a-z0-9]/gi, "").toLowerCase();\\n    return t === t.split("").reverse().join("");\\n}\\n'
        },
        'java': {
            'bullets': [
                'Use Character.isLetterOrDigit and Character.toLowerCase for normalization.',
                'Use two-pointer approach on a char array.',
            ],
            'pseudocode': 'public boolean is_palindrome(String s) {\\n    StringBuilder sb = new StringBuilder();\\n    for (char c: s.toCharArray()) if (Character.isLetterOrDigit(c)) sb.append(Character.toLowerCase(c));\\n    String t = sb.toString(); return new StringBuilder(t).reverse().toString().equals(t);\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Use isalnum from <cctype> and tolower for normalization.',
                'Build a filtered string and compare with reverse.',
            ],
            'pseudocode': 'bool is_palindrome(string s) {\\n    string t; for (char c: s) if (isalnum((unsigned char)c)) t.push_back(tolower((unsigned char)c)); return equal(t.begin(), t.begin()+t.size()/2, t.rbegin());\\n}\\n'
        },
    },
    'second_largest': {
        'python': {
            'bullets': [
                'Track top1 and top2 distinct values in one pass.',
                'Update top2 when you update top1; skip duplicates.',
            ],
            'pseudocode': 'def second_largest(nums):\\n    top1 = top2 = None\\n    for x in nums:\\n        if top1 is None or x > top1:\\n            if x != top1: top2 = top1\\n            top1 = x\\n        elif x != top1 and (top2 is None or x > top2):\\n            top2 = x\\n    return top2\\n'
        },
        'javascript': {
            'bullets': [
                'Track top1 and top2 distinct values in one pass.',
                'Update top2 when you update top1; skip duplicates.',
            ],
            'pseudocode': 'function secondLargest(nums) {\\n    let top1 = null, top2 = null;\\n    for (const x of nums) {\\n        if (top1 === null || x > top1) { if (x !== top1) top2 = top1; top1 = x; }\\n        else if (x !== top1 && (top2 === null || x > top2)) top2 = x;\\n    }\\n    return top2;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Track top1 and top2 distinct values in one pass.',
                'Update top2 when you update top1; skip duplicates.',
            ],
            'pseudocode': 'Integer secondLargest(int[] nums) {\\n    Integer top1 = null, top2 = null;\\n    for (int x : nums) {\\n        if (top1 == null || x > top1) { if (x != top1) top2 = top1; top1 = x; }\\n        else if (x != top1 && (top2 == null || x > top2)) top2 = x;\\n    }\\n    return top2;\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Track top1 and top2 distinct values in one pass.',
                'Update top2 when you update top1; skip duplicates.',
            ],
            'pseudocode': 'int secondLargest(vector<int>& nums) {\\n    int top1 = INT_MIN, top2 = INT_MIN;\\n    bool has1 = false, has2 = false;\\n    for (int x : nums) {\\n        if (!has1 || x > top1) { if (has1 && x != top1) { top2 = top1; has2 = true; } top1 = x; has1 = true; }\\n        else if (x != top1 && (!has2 || x > top2)) { top2 = x; has2 = true; }\\n    }\\n    return has2 ? top2 : INT_MIN;\\n}\\n'
        },
    },
    'frequency_sort': {
        'python': {
            'bullets': [
                'Count with collections.Counter.',
                'Sort by (-freq, char).',
                'Join char repeated freq times.',
            ],
            'pseudocode': 'from collections import Counter\\n\\ncounts = Counter(s)\\nparts = sorted(counts.items(), key=lambda kv: (-kv[1], kv[0]))\\nreturn "".join(ch*freq for ch,freq in parts)\\n'
        },
        'javascript': {
            'bullets': [
                'Count with a Map/object.',
                'Sort by (-freq, char).',
            ],
            'pseudocode': 'function frequencySort(s) {\\n    const counts = new Map();\\n    for (const c of s) counts.set(c, (counts.get(c) || 0) + 1);\\n    const parts = [...counts.entries()].sort((a,b) => b[1]-a[1] || a[0].localeCompare(b[0]));\\n    return parts.map(([ch, f]) => ch.repeat(f)).join("");\\n}\\n'
        },
        'java': {
            'bullets': [
                'Count with HashMap and sort entries.',
                'Sort by freq desc then char asc.',
            ],
            'pseudocode': 'String frequencySort(String s) {\\n    Map<Character, Integer> cnt = new HashMap<>();\\n    for (char c : s.toCharArray()) cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n    // Sort and build result\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Count with unordered_map and sort vector of pairs.',
                'Sort by freq desc then char asc.',
            ],
            'pseudocode': 'string frequencySort(string s) {\\n    unordered_map<char, int> cnt;\\n    for (char c : s) cnt[c]++;\\n    vector<pair<char, int>> v(cnt.begin(), cnt.end());\\n    sort(v.begin(), v.end(), [](auto &a, auto &b) {\\n        return a.second != b.second ? a.second > b.second : a.first < b.first;\\n    });\\n    string out;\\n    for (auto &p : v) out += string(p.second, p.first);\\n    return out;\\n}\\n'
        },
    },
    'merge_intervals': {
        'python': {
            'bullets': [
                'Sort by start.',
                'If current.start <= last.end, merge; else append.',
            ],
            'pseudocode': 'def merge_intervals(itv):\\n    itv.sort(key=lambda x: x[0])\\n    res = []\\n    for s, e in itv:\\n        if not res or s > res[-1][1]: res.append([s, e])\\n        else: res[-1][1] = max(res[-1][1], e)\\n    return res\\n'
        },
        'javascript': {
            'bullets': [
                'Sort and merge intervals similarly.',
            ],
            'pseudocode': 'function mergeIntervals(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    const res = [];\\n    for (const [s, e] of intervals) {\\n        if (!res.length || s > res[res.length-1][1]) res.push([s, e]);\\n        else res[res.length-1][1] = Math.max(res[res.length-1][1], e);\\n    }\\n    return res;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Sort intervals and merge in one pass.',
            ],
            'pseudocode': 'int[][] mergeIntervals(int[][] intervals) {\\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n    List<int[]> res = new ArrayList<>();\\n    for (int[] it : intervals) {\\n        if (res.isEmpty() || it[0] > res.get(res.size()-1)[1]) res.add(it);\\n        else res.get(res.size()-1)[1] = Math.max(res.get(res.size()-1)[1], it[1]);\\n    }\\n    return res.toArray(new int[res.size()][]);\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Sort and merge intervals.',
            ],
            'pseudocode': 'vector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) {\\n    sort(intervals.begin(), intervals.end());\\n    vector<vector<int>> res;\\n    for (auto &v : intervals) {\\n        if (res.empty() || v[0] > res.back()[1]) res.push_back(v);\\n        else res.back()[1] = max(res.back()[1], v[1]);\\n    }\\n    return res;\\n}\\n'
        },
    },
    'two_sum': {
        'python': {
            'bullets': [
                'One pass hashmap value->index.',
                'For x, need target-x; check before insert to avoid same index.',
            ],
            'pseudocode': 'def two_sum(a, t):\\n    seen = {}\\n    for i,x in enumerate(a):\\n        y = t - x\\n        if y in seen: return [seen[y], i]\\n        seen[x] = i\\n    return [-1,-1]\\n'
        },
        'javascript': {
            'bullets': [
                'Use a Map to store seen values to indices.',
                'Be mindful of === vs == when comparing.',
            ],
            'pseudocode': 'function two_sum(nums, target) {\\n    const seen = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        const y = target - nums[i];\\n        if (seen.has(y)) return [seen.get(y), i];\\n        seen.set(nums[i], i);\\n    }\\n    return [-1, -1];\\n}\\n'
        },
        'java': {
            'bullets': [
                'Use HashMap<Integer,Integer> to map value→index.',
                'Beware of integer boxing/unboxing; use primitives where convenient.',
            ],
            'pseudocode': 'public int[] two_sum(int[] nums, int target) {\\n    Map<Integer,Integer> seen = new HashMap<>();\\n    for (int i=0;i<nums.length;i++) {\\n        int y = target - nums[i];\\n        if (seen.containsKey(y)) return new int[]{seen.get(y), i};\\n        seen.put(nums[i], i);\\n    }\\n    return new int[]{-1,-1};\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Use unordered_map<int,int> for O(1) lookups.',
                'Return vector<int>{idx1, idx2} or {-1,-1} if not found.',
            ],
            'pseudocode': 'vector<int> two_sum(vector<int>& nums, int target) {\\n    unordered_map<int,int> seen;\\n    for (int i=0;i<nums.size();++i) {\\n        int y = target - nums[i];\\n        if (seen.count(y)) return {seen[y], i};\\n        seen[nums[i]] = i;\\n    }\\n    return {-1,-1};\\n}\\n'
        },
    },
    'balanced_brackets': {
        'python': {
            'bullets': [
                'Use a stack for opens.',
                'Map closes to opens and match as you go.',
                'Valid if stack empty at end.',
            ],
            'pseudocode': 'def valid(s):\\n    pairs = {")":"(", "]":"[", "}":"{"}\\n    stack = []\\n    for c in s:\\n        if c in "([{": stack.append(c)\\n        elif c in ")]}": \\n            if not stack or stack[-1] != pairs[c]: return False\\n            stack.pop()\\n    return not stack\\n'
        },
        'javascript': {
            'bullets': [
                'Use an array as a stack, map closing to opening char.',
            ],
            'pseudocode': 'function isValid(s) {\\n    const pairs = {")":"(", "]":"[", "}":"{"};\\n    const st = [];\\n    for (const c of s) {\\n        if ("([{".includes(c)) st.push(c);\\n        else if (st.length === 0 || st.pop() !== pairs[c]) return false;\\n    }\\n    return st.length === 0;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Use Deque/Stack to track opens.',
            ],
            'pseudocode': 'boolean isValid(String s) {\\n    Map<Character,Character> pairs = Map.of(\\n        \\\')\\\', \\\'(\\\', \\\']\\\', \\\'[\\\', \\\'}\\\', \\\'{\\\');\\n    Deque<Character> st = new ArrayDeque<>();\\n    for (char c : s.toCharArray()) {\\n        if (pairs.containsValue(c)) st.push(c);\\n        else if (st.isEmpty() || st.pop() != pairs.get(c)) return false;\\n    }\\n    return st.isEmpty();\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Use vector<char> as stack and mapping for closes.',
            ],
            'pseudocode': 'bool isValid(string s) {\\n    unordered_map<char,char> pairs = {{\\\')\\\',\\\'(\\\'},{\\\']\\\',\\\'[\\\'},{\\\'}\\\',\\\'{\\\'}}; \\n    vector<char> st;\\n    for (char c : s) {\\n        if (c==\\\'(\\\'||c==\\\'[\\\'||c==\\\'{\\\') st.push_back(c);\\n        else if (st.empty() || st.back()!=pairs[c]) return false; else st.pop_back();\\n    }\\n    return st.empty();\\n}\\n'
        },
    },
    'max_subarray': {
        'python': {
            'bullets': [
                "Kadane's algorithm: track current and best sum.",
                'current = max(x, current + x).',
            ],
            'pseudocode': 'best = cur = nums[0]\\nfor x in nums[1:]:\\n    cur = max(x, cur + x)\\n    best = max(best, cur)\\nreturn best\\n'
        },
        'javascript': {
            'bullets': [
                "Kadane's algorithm",
            ],
            'pseudocode': 'function maxSubarray(nums) {\\n    let best = nums[0], cur = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        cur = Math.max(nums[i], cur + nums[i]);\\n        best = Math.max(best, cur);\\n    }\\n    return best;\\n}\\n'
        },
        'java': {
            'bullets': [
                "Kadane's algorithm",
            ],
            'pseudocode': 'int maxSubarray(int[] nums) {\\n    int best = nums[0], cur = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        cur = Math.max(nums[i], cur + nums[i]);\\n        best = Math.max(best, cur);\\n    }\\n    return best;\\n}\\n'
        },
        'cpp': {
            'bullets': [
                "Kadane's algorithm",
            ],
            'pseudocode': 'int maxSubarray(vector<int>& nums) {\\n    int best = nums[0], cur = nums[0];\\n    for (size_t i = 1; i < nums.size(); ++i) {\\n        cur = max(nums[i], cur + nums[i]);\\n        best = max(best, cur);\\n    }\\n    return best;\\n}\\n'
        },
    },
    'product_except_self': {
        'python': {
            'bullets': [
                'Compute prefix products then multiply by suffix pass.',
                'O(n) time, O(1) extra arrays aside from output.',
            ],
            'pseudocode': 'n = len(nums)\\nres = [1] * n\\npre = 1\\nfor i in range(n):\\n    res[i] = pre\\n    pre *= nums[i]\\nsuf = 1\\nfor i in range(n-1, -1, -1):\\n    res[i] *= suf\\n    suf *= nums[i]\\nreturn res\\n'
        },
        'javascript': {
            'bullets': [
                'Compute prefix and suffix products.',
            ],
            'pseudocode': 'function productExceptSelf(nums) {\\n    const n = nums.length, res = Array(n).fill(1);\\n    let pre = 1;\\n    for (let i = 0; i < n; i++) { res[i] = pre; pre *= nums[i]; }\\n    let suf = 1;\\n    for (let i = n-1; i >= 0; i--) { res[i] *= suf; suf *= nums[i]; }\\n    return res;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Compute prefix and suffix without division.',
            ],
            'pseudocode': 'int[] productExceptSelf(int[] nums) {\\n    int n = nums.length, res[] = new int[n];\\n    Arrays.fill(res, 1);\\n    int pre = 1;\\n    for (int i = 0; i < n; i++) { res[i] = pre; pre *= nums[i]; }\\n    int suf = 1;\\n    for (int i = n-1; i >= 0; i--) { res[i] *= suf; suf *= nums[i]; }\\n    return res;\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Compute prefix and suffix.',
            ],
            'pseudocode': 'vector<int> productExceptSelf(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> res(n, 1);\\n    int pre = 1;\\n    for (int i = 0; i < n; i++) { res[i] = pre; pre *= nums[i]; }\\n    int suf = 1;\\n    for (int i = n-1; i >= 0; i--) { res[i] *= suf; suf *= nums[i]; }\\n    return res;\\n}\\n'
        },
    },
    'three_sum': {
        'python': {
            'bullets': [
                'Sort array; fix i; two-pointer on [i+1..].',
                'Skip duplicates at i and while moving pointers.',
            ],
            'pseudocode': 'nums.sort()\\nres = []\\nfor i, x in enumerate(nums):\\n    if i and nums[i] == nums[i-1]: continue\\n    l, r = i+1, len(nums)-1\\n    while l < r:\\n        s = x + nums[l] + nums[r]\\n        if s == 0:\\n            res.append([x, nums[l], nums[r]])\\n            l += 1; r -= 1\\n            while l < r and nums[l] == nums[l-1]: l += 1\\n            while l < r and nums[r] == nums[r+1]: r -= 1\\n        elif s < 0: l += 1\\n        else: r -= 1\\nreturn res\\n'
        },
        'javascript': {
            'bullets': [
                'Sort and use two-pointer technique.',
            ],
            'pseudocode': 'function threeSum(nums) {\\n    nums.sort((a, b) => a - b);\\n    const res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i && nums[i] == nums[i-1]) continue;\\n        let l = i+1, r = nums.length-1;\\n        while (l < r) {\\n            const s = nums[i] + nums[l] + nums[r];\\n            if (s == 0) {\\n                res.push([nums[i], nums[l], nums[r]]);\\n                l++; r--;\\n                while (l < r && nums[l] == nums[l-1]) l++;\\n                while (l < r && nums[r] == nums[r+1]) r--;\\n            } else if (s < 0) l++;\\n            else r--;\\n        }\\n    }\\n    return res;\\n}\\n'
        },
        'java': {
            'bullets': [
                'Sort and two-pointer approach.',
            ],
            'pseudocode': 'List<List<Integer>> threeSum(int[] nums) {\\n    Arrays.sort(nums);\\n    List<List<Integer>> res = new ArrayList<>();\\n    for (int i = 0; i < nums.length; i++) {\\n        if (i > 0 && nums[i] == nums[i-1]) continue;\\n        int l = i+1, r = nums.length-1;\\n        while (l < r) {\\n            int s = nums[i] + nums[l] + nums[r];\\n            if (s == 0) {\\n                res.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n                l++; r--;\\n                while (l < r && nums[l] == nums[l-1]) l++;\\n                while (l < r && nums[r] == nums[r+1]) r--;\\n            } else if (s < 0) l++;\\n            else r--;\\n        }\\n    }\\n    return res;\\n}\\n'
        },
        'cpp': {
            'bullets': [
                'Sort and two-pointer approach.',
            ],
            'pseudocode': 'vector<vector<int>> threeSum(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    vector<vector<int>> res;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        if (i && nums[i] == nums[i-1]) continue;\\n        int l = i+1, r = nums.size()-1;\\n        while (l < r) {\\n            int s = nums[i] + nums[l] + nums[r];\\n            if (s == 0) {\\n                res.push_back({nums[i], nums[l], nums[r]});\\n                l++; r--;\\n                while (l < r && nums[l] == nums[l-1]) l++;\\n                while (l < r && nums[r] == nums[r+1]) r--;\\n            } else if (s < 0) l++;\\n            else r--;\\n        }\\n    }\\n    return res;\\n}\\n'
        },
    },
    'two_sum_sorted': {
        'bullets': ['Use two pointers from ends.', 'Move left if sum<target else move right.'],
        'pseudocode': 'l,r=0,len(nums)-1\nwhile l<r:\n  s=nums[l]+nums[r]\n  if s==target: return [l,r]\n  if s<target: l+=1\n  else: r-=1\nreturn [-1,-1]\n'
    },
    'longest_substring_without_repeating_characters': {
        'bullets': ['Sliding window with last seen position.', 'Move left to max(left, last[c]+1).'],
        'pseudocode': 'last={}; left=0; best=0\nfor i,c in enumerate(s):\n  if c in last: left=max(left,last[c]+1)\n  last[c]=i\n  best=max(best,i-left+1)\nreturn best\n'
    },
    'group_anagrams': {
        'bullets': ['Key by sorted word or 26-letter counts.', 'Sort groups for deterministic output.'],
        'pseudocode': 'from collections import defaultdict\nmp=defaultdict(list)\nfor w in strs:\n  key=\"\".join(sorted(w))\n  mp[key].append(w)\nreturn [sorted(v) for v in sorted(mp.values(), key=lambda x: (len(x), x))]\n'
    },
    'top_k_frequent': {
        'bullets': ['Use Counter to count, then sort by -freq.', 'Return ascending for determinism if same freq.'],
        'pseudocode': 'from collections import Counter\ncounts=Counter(nums)\nitems=sorted(counts.items(), key=lambda kv:(-kv[1], kv[0]))\nreturn [x for x,_ in items[:k]]\n'
    },
    'kth_largest': {
        'bullets': ['Quickselect or heap; quickselect is average O(n).'],
        'pseudocode': '# quickselect partition around pivot to find index n-k\n'
    },
    'binary_search': {
        'bullets': ['Classic low<=high, mid=(l+r)//2.', 'Compare and shrink range.'],
        'pseudocode': 'l,r=0,len(nums)-1\nwhile l<=r:\n  m=(l+r)//2\n  if nums[m]==target: return m\n  if nums[m]<target: l=m+1\n  else: r=m-1\nreturn -1\n'
    },
    'search_rotated_sorted_array': {
        'bullets': ['One half is sorted at each step.', 'Check which half target lies in and adjust.'],
        'pseudocode': 'l,r=0,len(nums)-1\nwhile l<=r:\n  m=(l+r)//2\n  if nums[m]==target: return m\n  if nums[l]<=nums[m]:\n    if nums[l]<=target<nums[m]: r=m-1\n    else: l=m+1\n  else:\n    if nums[m]<target<=nums[r]: l=m+1\n    else: r=m-1\nreturn -1\n'
    },
    'max_product_subarray': {
        'bullets': ['Track both max and min due to negatives.', 'Swap when x<0.'],
        'pseudocode': 'best=hi=lo=nums[0]\nfor x in nums[1:]:\n  if x<0: hi,lo=lo,hi\n  hi=max(x, hi*x); lo=min(x, lo*x)\n  best=max(best, hi)\nreturn best\n'
    },
    'coin_change': {
        'bullets': ['Bottom-up DP: dp[a]=min(dp[a], dp[a-c]+1).', 'Initialize dp with inf and dp[0]=0.'],
        'pseudocode': 'dp=[10**9]*(amount+1); dp[0]=0\nfor c in coins:\n  for a in range(c, amount+1):\n    dp[a]=min(dp[a], dp[a-c]+1)\nreturn dp[amount] if dp[amount]<10**9 else -1\n'
    },
    'climb_stairs': {
        'python': {
            'bullets': ['Fibonacci: f(n)=f(n-1)+f(n-2).', 'Iterative O(1) space.'],
            'pseudocode': 'a,b=1,1\\nfor _ in range(n-1): a,b=b,a+b\\nreturn b if n>0 else 1\\n'
        },
        'javascript': {
            'bullets': ['Fibonacci: f(n)=f(n-1)+f(n-2).', 'Iterative O(1) space.'],
            'pseudocode': 'function climb_stairs(n) {\\n    let a=1,b=1; for (let i=0;i<n-1;i++){ [a,b]=[b,a+b]; } return n>0?b:1; }\\n'
        },
        'java': {
            'bullets': ['Fibonacci relation; iterative approach preferred to recursion.', 'Use int/long depending on n.'],
            'pseudocode': 'public int climb_stairs(int n) {\\n    int a=1,b=1; for (int i=0;i<n-1;i++){ int t=b; b=a+b; a=t; } return n>0?b:1; }\\n'
        },
        'cpp': {
            'bullets': ['Fibonacci relation; iterative approach preferred to recursion.', 'Use int/long depending on n.'],
            'pseudocode': 'int climb_stairs(int n) {\\n    int a=1,b=1; for (int i=0;i<n-1;i++){ int t=b; b=a+b; a=t; } return n>0?b:1; }\\n'
        },
    },
    'min_window_substring': {
        'bullets': ['Sliding window with need/have counts.', 'Expand right until valid, then shrink left.'],
        'pseudocode': '# Use Counter for t; track formed == required distinct chars.\n'
    },
    'longest_palindromic_substring': {
        'bullets': ['Expand-around-center for each i (odd and even).'],
        'pseudocode': 'def expand(l,r):\n  while l>=0 and r<len(s) and s[l]==s[r]: l-=1; r+=1\n  return l+1,r-1\n# track best window\n'
    },
    'rotate_matrix': {
        'bullets': ['Transpose then reverse each row (in-place) or build new using zip.'],
        'pseudocode': 'return [list(row)[::-1] for row in zip(*matrix)]\n'
    },
    'number_of_islands': {
        'python': {
            'bullets': ['Scan grid; when you see "1", DFS/BFS to mark all connected land to "0".', 'Use bounds checks and 4-direction neighbors.'],
            'pseudocode': 'def dfs(r,c):\\n  if out_of_bounds or grid[r][c]!="1": return\\n  grid[r][c]="0"\\n  for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]: dfs(r+dr,c+dc)\\ncount=0\\nfor r in range(R):\\n  for c in range(C):\\n    if grid[r][c]=="1": count+=1; dfs(r,c)\\nreturn count\\n'
        },
        'javascript': {
            'bullets': ['Scan grid; use DFS/BFS to mark visited cells.', 'Be careful with in-place modification vs copying.'],
            'pseudocode': 'function numIslands(grid) {\\n    const R=grid.length, C=grid[0].length; function dfs(r,c){ if(r<0||c<0||r>=R||c>=C||grid[r][c]==="0") return; grid[r][c]="0"; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>dfs(r+dr,c+dc)); } let count=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(grid[r][c]==="1"){count++; dfs(r,c);} return count; }\\n'
        },
        'java': {
            'bullets': ['Scan grid; perform DFS/BFS using recursion or stack.', 'Mark visited cells to avoid recounting.'],
            'pseudocode': 'public int numIslands(char[][] grid) {\\n    int R=grid.length, C=grid[0].length; for(int r=0;r<R;r++) for(int c=0;c<C;c++) if(grid[r][c]==\'1\'){ dfs(grid,r,c); count++; } return count; }\\n'
        },
        'cpp': {
            'bullets': ['Use DFS/BFS and mark visited cells.', 'Watch recursion depth for large grids; consider iterative stack.'],
            'pseudocode': 'int numIslands(vector<vector<char>>& grid) {\\n    int R=grid.size(), C=grid[0].size(); function<void(int,int)> dfs = [&](int r,int c){ if(r<0||c<0||r>=R||c>=C||grid[r][c]==\'0\') return; grid[r][c]=\'0\'; dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1); }; int count=0; for(int r=0;r<R;r++) for(int c=0;c<C;c++) if(grid[r][c]==\'1\'){count++; dfs(r,c);} return count; }\\n'
        },
    },
}


def get_hints_for(problem_name: str, language: str) -> dict:
    """Return hints for a problem adapted to the requested language.
    HINTS entries may be either the old flat format ({'bullets':..., 'pseudocode':...})
    or a per-language mapping (e.g. {'python': {...}, 'java': {...}}).
    This helper returns a dict with keys 'bullets' and 'pseudocode'.
    """
    default = {'bullets': ['No hints available yet.'], 'pseudocode': ''}
    if problem_name not in HINTS:
        return default
    entry = HINTS[problem_name]
    # If entry already in new per-language shape
    if isinstance(entry, dict):
        # If it looks like a language-keyed mapping (contains language keys)
        if language in entry:
            return entry.get(language, default)
        # Backwards-compatible: if entry has 'bullets' treat it as legacy
        if 'bullets' in entry or 'pseudocode' in entry:
            return {
                'bullets': entry.get('bullets', default['bullets']),
                'pseudocode': entry.get('pseudocode', default['pseudocode'])
            }
        # If there's a 'default' key
        if 'default' in entry:
            return entry.get('default', default)
    return default

# Global glossary of common CS/algorithms terms
GLOSSARY = {
    'palindrome': """A string/sequence that reads the same forward and backward.
    - Normalization: often lowercase and strip non-alphanumerics.
    - Examples: "racecar", "A man, a plan, a canal: Panama" (ignoring spaces/punctuation).
    - Typical check: two pointers from ends or compare to reversed string.
    """,
    'two pointers': """Technique with two indices that move based on comparisons.
    - Patterns: opposite ends (palindrome), fast/slow (cycle), left/right window edges.
    - Why: reduces nested loops (O(n^2)) to linear (O(n)) for ordered/structured data.
    """,
    'hash map (dict)': """Key→value structure with average O(1) insert/lookup.
    - Python: dict; Common uses: Two Sum, frequency counts, last-seen indices.
    - Tip: Be careful with mutable keys; use tuples/strings as keys.
    """,
    'stack': """LIFO structure with push/pop in O(1).
    - Common in: balanced parentheses, DFS (iterative), undo operations.
    - Python: use list with append()/pop(), or collections.deque.
    """,
    'sliding window': """Maintain a window [l, r] and adjust by growing/shrinking.
    - Works best on arrays/strings to track counts/constraints (e.g., longest substring without repeats).
    - Tools: hash map for counts, a variable to track satisfaction of constraints.
    """,
    "Kadane's algorithm": """Linear-time algorithm for maximum subarray sum.
    - Idea: cur = max(x, cur+x); best = max(best, cur) as you scan.
    - Works because negative prefixes only hurt future sums.
    """,
    'binary search': """Search in sorted data by halving the interval each step.
    - Complexity: O(log n). Careful with mid calc and loop conditions.
    - Generalize to answer minimization/maximization via predicate (binary search on answer).
    """,
    'anagram': """Two strings with the same multiset of characters.
    - Checks: sort both strings or compare frequency counts.
    - Be mindful of unicode/case if required.
    """,
    'frequency count': """Counting occurrences of items.
    - Python: collections.Counter or dict with increment.
    - Used in: top-k frequent, anagrams, sliding window.
    """,
    'prefix/suffix product': """Cumulative products from left/right to compute product-except-self.
    - Avoids division and handles zeros gracefully.
    - Build prefix array, then multiply by running suffix on a backward pass.
    """,
    'heap': """Priority queue; Python's heapq is a min-heap.
    - Patterns: track top-k, merge k lists, Dijkstra.
    - For max-heap: push negatives or use nlargest.
    """,
    'quickselect': """Average O(n) selection for k-th smallest/largest using partition.
    - Uses a pivot to place elements < pivot to left and > pivot to right.
    - Recurse into the side containing the k-th index.
    """,
    'rotate matrix': """Rotate a matrix 90° clockwise.
    - Methods: transpose + reverse rows (in-place) or zip(*matrix) to build new.
    - In-place requires careful index swapping.
    """,
    'DFS': """Depth-First Search explores branches fully before backtracking.
    - Implement via recursion or an explicit stack.
    - Use to traverse graphs, flood-fill, topological sort (with visited).
    """,
    'BFS': """Breadth-First Search explores level by level using a queue.
    - Shortest path in unweighted graphs, level-order traversal of trees.
    - Python: collections.deque for efficient popleft().
    """,
    'island': """A connected component of '1's in a grid using 4-direction adjacency.
    - Count islands by scanning and flood-filling each discovered land cell.
    - Mark visited by turning to '0' or a visited set.
    """,
    'window': """The current inclusive range [l, r] for a sliding window algorithm.
    - Expand r to include more; shrink l to restore constraints.
    - Track when the window is "valid" to update best answers.
    """,
    'pivot': """A chosen value/index used to partition arrays in quicksort/quickselect.
    - Good pivots balance partitions; randomization reduces worst-case risk.
    """,
    'in-place': """Transforms data using O(1) extra space (ignoring recursion/stack).
    - Often modifies input arrays directly; beware of aliasing and iteration order.
    """,
    'time complexity': """Asymptotic running time as input size grows.
    - Common: O(1), O(log n), O(n), O(n log n), O(n^2).
    - Prefer linear or n log n when feasible.
    """,
    'dynamic programming': """Optimize recursive problems by storing subproblem results.
    - Two styles: top-down (memoization) and bottom-up (tabulation).
    - Hallmarks: optimal substructure + overlapping subproblems.
    - Examples: coin change, climbing stairs, edit distance.
    """,
}

# Optional mapping of problems to relevant glossary terms
PROBLEM_TERMS = {
    'palindrome': ['palindrome', 'two pointers'],
    'two_sum': ['hash map (dict)'],
    'two_sum_sorted': ['two pointers', 'binary search'],
    'longest_substring_without_repeating_characters': ['sliding window', 'hash map (dict)', 'window'],
    'max_subarray': ["Kadane's algorithm"],
    'product_except_self': ['prefix/suffix product'],
    'group_anagrams': ['anagram', 'frequency count', 'hash map (dict)'],
    'top_k_frequent': ['frequency count', 'heap'],
    'kth_largest': ['quickselect', 'heap', 'pivot'],
    'binary_search': ['binary search'],
    'search_rotated_sorted_array': ['binary search', 'pivot'],
    'max_product_subarray': ['two pointers'],
    'coin_change': ['dynamic programming', 'time complexity'],
    'climb_stairs': ['dynamic programming', 'time complexity'],
    'min_window_substring': ['sliding window', 'window', 'hash map (dict)'],
    'longest_palindromic_substring': ['two pointers'],
    'rotate_matrix': ['rotate matrix', 'in-place'],
    'number_of_islands': ['DFS', 'BFS', 'island'],
    'merge_intervals': ['two pointers', 'time complexity'],
    'frequency_sort': ['frequency count'],
    'balanced_brackets': ['stack'],
}

@app.route('/')
def index():
    return send_from_directory('static', 'index.html')

@app.route('/api/problems', methods=['GET'])
def get_problems():
    """Return list of all problems."""
    return jsonify([{
        'name': p['name'],
        'title': p['title'],
        'description': p['description']
    } for p in PROBLEMS.values()])

@app.route('/api/problem/<name>', methods=['GET'])
def get_problem(name):
    """Return problem details including stub code."""
    if name not in PROBLEMS:
        return jsonify({'error': 'Problem not found'}), 404
    
    problem = PROBLEMS[name]
    language = request.args.get('language', 'python')
    
    # Get language-specific stub from problem definition
    if 'stubs' in problem and language in problem['stubs']:
        stub_code = problem['stubs'][language]
    else:
        # Fallback to Python file if stubs not defined
        stub_path = os.path.join('problems', f'{name}.py')
        try:
            with open(stub_path, 'r') as f:
                stub_code = f.read()
        except FileNotFoundError:
            stub_code = f"{problem.get('signature', '')}\n    # Write your code here\n    pass\n"
    
    return jsonify({
        'name': problem['name'],
        'title': problem['title'],
        'description': problem['description'],
        'signature': problem.get('signature', ''),
        'stub': stub_code,
        'language': language,
        'hints': get_hints_for(name, language),
        'terms': PROBLEM_TERMS.get(name, []),
        'tests': [{'args': str(t['args']), 'expected': str(t['expected'])} for t in problem['tests']]
    })

@app.route('/api/glossary', methods=['GET'])
def get_glossary():
    """Return the global glossary of terms."""
    return jsonify(GLOSSARY)

@app.route('/api/submit', methods=['POST'])
def submit_solution():
    """Execute user code against test cases and return results."""
    data = request.json
    if not data:
        return jsonify({'error': 'Invalid JSON data'}), 400
    
    problem_name = data.get('problem')
    code = data.get('code', '')
    language = data.get('language', 'python')
    
    if problem_name not in PROBLEMS:
        return jsonify({'error': 'Invalid problem'}), 400
    
    if language not in LANGUAGE_EXECUTORS:
        return jsonify({'error': f'Unsupported language: {language}'}), 400
    
    problem = PROBLEMS[problem_name]
    func_name = problem_name if problem_name != 'palindrome' else 'is_palindrome'
    
    results = []
    passed = 0
    failed = 0
    
    executor = LANGUAGE_EXECUTORS[language]
    
    # Run test cases
    for i, test in enumerate(problem['tests']):
        test_result = {
            'test_num': i + 1,
            'args': str(test['args']),
            'expected': str(test['expected']),
            'actual': None,
            'passed': False,
            'error': None
        }
        
        try:
            result, stdout, stderr = executor(code, func_name, test['args'])
            
            test_result['actual'] = str(result)
            test_result['stdout'] = stdout
            test_result['stderr'] = stderr
            
            if result == test['expected']:
                test_result['passed'] = True
                passed += 1
            else:
                failed += 1
        except Exception as e:
            test_result['error'] = f'{type(e).__name__}: {str(e)}'
            test_result['traceback'] = traceback.format_exc()
            failed += 1
        
        results.append(test_result)
    
    return jsonify({
        'passed': passed,
        'failed': failed,
        'total': len(problem['tests']),
        'results': results
    })

def _safe_repr(obj, max_len=200):
    try:
        s = repr(obj)
    except Exception as e:
        s = f'<unreprable {type(obj).__name__}: {e}>'
    if len(s) > max_len:
        s = s[:max_len] + '…'
    return s

@app.route('/api/debug', methods=['POST'])
def debug_solution():
    """Run user code with a simple tracer and return a recorded execution trace.
    Request JSON:
    {
        problem: str,
        code: str,
        testIndex?: int,           # optional: choose problem test cases
        customArgsJson?: str,      # optional: JSON array of args, e.g., ["abc", 2]
        breakpoints?: [int],       # optional: line numbers in user's code (1-based)
        maxSteps?: int             # optional: cap recorded steps (default 500)
    }
    """
    data = request.json or {}
    problem_name = data.get('problem')
    code = data.get('code', '')
    if problem_name not in PROBLEMS:
        return jsonify({'error': 'Invalid problem'}), 400

    problem = PROBLEMS[problem_name]
    func_name = problem_name if problem_name != 'palindrome' else 'is_palindrome'

    # Determine args
    args = None
    if 'testIndex' in data and isinstance(data['testIndex'], int):
        i = data['testIndex']
        try:
            args = problem['tests'][i]['args']
        except Exception:
            return jsonify({'error': 'Invalid testIndex'}), 400
    elif 'customArgsJson' in data and data['customArgsJson']:
        try:
            parsed = json.loads(data['customArgsJson'])
            if not isinstance(parsed, list):
                return jsonify({'error': 'customArgsJson must be a JSON array'}), 400
            args = tuple(parsed)
        except json.JSONDecodeError as e:
            return jsonify({'error': f'Invalid JSON for customArgsJson: {e}'}), 400
    else:
        # Default to first test case if available
        args = problem['tests'][0]['args'] if problem['tests'] else tuple()

    # Prepare tracing
    breakpoints = set(int(b) for b in data.get('breakpoints', []) if isinstance(b, int) or str(b).isdigit())
    max_steps = int(data.get('maxSteps', 500))
    code_lines = code.splitlines()
    trace = []
    truncated = False

    def tracer(frame, event, arg):
        nonlocal truncated
        # Only trace user code submitted via exec (filename will be '<string>')
        if frame.f_code.co_filename != '<string>':
            return tracer
        if event in ('call', 'line', 'return'):
            line_no = frame.f_lineno
            record_this = not breakpoints or (line_no in breakpoints)
            if record_this:
                try:
                    locals_snapshot = {k: _safe_repr(v) for k, v in frame.f_locals.items()}
                except Exception:
                    locals_snapshot = {}
                step = {
                    'event': event,
                    'line': line_no,
                    'code': code_lines[line_no-1] if 1 <= line_no <= len(code_lines) else '',
                    'locals': locals_snapshot,
                }
                if event == 'return':
                    step['return'] = _safe_repr(arg)
                trace.append(step)
                if len(trace) >= max_steps:
                    truncated = True
                    sys.settrace(None)
                    return None
        return tracer

    # Execute code with tracing
    namespace = {}
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    try:
        exec(code, namespace)
        if func_name not in namespace:
            return jsonify({'error': f'Function {func_name} not found in submitted code'}), 400

        user_func = namespace[func_name]
        sys.settrace(tracer)
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            retval = user_func(*args)
    except Exception as e:
        # Ensure tracing is disabled in case of error
        sys.settrace(None)
        return jsonify({
            'error': f'{type(e).__name__}: {e}',
            'trace': trace,
            'stdout': stdout_capture.getvalue(),
            'stderr': stderr_capture.getvalue(),
        })
    finally:
        sys.settrace(None)

    return jsonify({
        'trace': trace,
        'truncated': truncated,
        'stdout': stdout_capture.getvalue(),
        'stderr': stderr_capture.getvalue(),
        'return': _safe_repr(retval),
        'argsUsed': _safe_repr(args),
    })

@app.route('/api/ask', methods=['POST'])
def ask_ai():
    """Proxy a question to OpenAI with optional problem context.
    Request JSON:
    {
      prompt: str,
      problem?: str,
      includeDescription?: bool,
      includeCode?: bool,
      includeHints?: bool,
      includeTests?: bool,
      code?: str  # optional current editor code (if includeCode true)
    }
    """
    # Attempt to re-read .env safely before proceeding so changes are picked up at runtime.
    parsed_key, msg = reload_env_if_valid()
    if not parsed_key and not OPENAI_API_KEY:
        # If reload failed and we don't have a key yet, surface the validation message
        return jsonify({'error': f'Missing or invalid OPENAI_API_KEY: {msg}'}), 400
    # Prefer the parsed key if present, otherwise fall back to the previously loaded environment key
    effective_key = parsed_key if parsed_key else OPENAI_API_KEY

    data = request.json or {}
    user_prompt = (data.get('prompt') or '').strip()
    if not user_prompt:
        return jsonify({'error': 'Prompt is required'}), 400

    problem_name = data.get('problem')
    language = data.get('language', 'python')
    include_description = bool(data.get('includeDescription'))
    include_code = bool(data.get('includeCode'))
    include_hints = bool(data.get('includeHints'))
    include_tests = bool(data.get('includeTests'))
    current_code = data.get('code') or ''

    # Add language context
    language_names = {
        'python': 'Python',
        'javascript': 'JavaScript',
        'java': 'Java',
        'cpp': 'C++'
    }
    lang_context = f"The user is working in {language_names.get(language, language)}."

    context_parts = [lang_context]
    if problem_name and problem_name in PROBLEMS:
        p = PROBLEMS[problem_name]
        title = p.get('title', problem_name)
        if include_description:
            context_parts.append(f"Problem: {title}\nDescription: {p.get('description','')}")
        if include_tests and p.get('tests'):
            tests_str = "\n".join([f"- args={t['args']} expected={t['expected']}" for t in p['tests']])
            context_parts.append(f"Sample tests:\n{tests_str}")
        if include_hints:
            h = get_hints_for(problem_name, language)
            bullets = "\n".join([f"• {b}" for b in h.get('bullets', [])])
            pseudo = h.get('pseudocode', '').strip()
            if bullets:
                context_parts.append(f"Hints:\n{bullets}")
            if pseudo:
                context_parts.append(f"Pseudocode:\n{pseudo}")
    if include_code and current_code:
        snippet = current_code.strip()
        if len(snippet) > 4000:
            snippet = snippet[:4000] + "\n# … truncated …"
        context_parts.append("Current code:\n" + snippet)

    full_user = user_prompt
    if context_parts:
        full_user += "\n\n---\nContext:\n" + "\n\n".join(context_parts)

    # Compose Chat Completions request
    language_tutor_names = {
        'python': 'Python',
        'javascript': 'JavaScript',
        'java': 'Java',
        'cpp': 'C++'
    }
    tutor_lang = language_tutor_names.get(language, 'programming')
    
    payload = {
        'model': OPENAI_MODEL,
        'messages': [
            {
                'role': 'system',
                'content': (
                    f'You are a concise, friendly {tutor_lang} algorithms tutor. '
                    'Explain step by step when helpful, and prefer clarity over verbosity. '
                    f'Use short {tutor_lang} code snippets only if explicitly asked or when crucial. '
                    f'Provide language-specific best practices and idioms for {tutor_lang}.'
                )
            },
            {'role': 'user', 'content': full_user}
        ],
        'temperature': 0.3,
        'max_tokens': 700,
    }

    req = urlrequest.Request(
        url='https://api.openai.com/v1/chat/completions',
        data=json.dumps(payload).encode('utf-8'),
        headers={
            'Authorization': f'Bearer {effective_key}',
            'Content-Type': 'application/json'
        },
        method='POST'
    )
    # Tolerate environments with strict SSL
    ctx = ssl.create_default_context()
    try:
        with urlrequest.urlopen(req, context=ctx, timeout=30) as resp:
            body = resp.read().decode('utf-8')
            data = json.loads(body)
            answer = data.get('choices', [{}])[0].get('message', {}).get('content', '').strip()
            if not answer:
                return jsonify({'error': 'Empty response from AI'}), 502
            return jsonify({'answer': answer})
    except HTTPError as e:
        try:
            err_body = e.read().decode('utf-8')
        except Exception:
            err_body = ''
        return jsonify({'error': f'HTTP {e.code}: {err_body or e.reason}'}), 502
    except URLError as e:
        return jsonify({'error': f'Network error: {e.reason}'}), 502
    except Exception as e:
        return jsonify({'error': f'Unexpected error: {e}'}), 500


@app.route('/api/ask/status', methods=['GET'])
def ask_status():
    """Return whether the AI feature is enabled (OPENAI_API_KEY present)."""
    enabled = bool(OPENAI_API_KEY)
    msg = 'enabled' if enabled else 'missing OPENAI_API_KEY in environment/.env'
    return jsonify({'enabled': enabled, 'message': msg})

if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=5000)
